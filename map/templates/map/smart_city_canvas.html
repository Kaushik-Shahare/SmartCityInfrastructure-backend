<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart City Infrastructure Visualization</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
    <style>
        :root {
            --primary: #4361ee;
            --primary-light: #4895ef;
            --secondary: #3a0ca3;
            --success: #4cc9f0;
            --danger: #f72585;
            --warning: #ffd166;
            --info: #0096c7;
            --dark: #192841;
            --light: #f8f9fa;
            --white: #ffffff;
            --gray: #6c757d;
            
            --road-color: #ffd166;            /* Vibrant yellow */
            --building-color: #4361ee;        /* Vibrant blue */
            --park-color: #06d6a0;            /* Vibrant green */
            --water-color: #118ab2;           /* Mid blue */
            --other-color: #adb5bd;           /* Gray */
            
            --explored-color: rgba(247, 37, 133, 0.3); /* Semi-transparent pink */
            --path-color: rgba(247, 37, 133, 0.8);     /* More opaque pink */
            
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
            
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;
            
            --transition: all 0.2s ease-in-out;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
            color: var(--dark);
            line-height: 1.5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }
        
        h1, h2, h3 {
            font-weight: 600;
            margin-bottom: 1rem;
        }
        
        h1 {
            font-size: 2.5rem;
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 1.5rem;
        }
        
        h2 {
            font-size: 1.5rem;
            color: var(--dark);
        }
        
        h3 {
            font-size: 1.2rem;
            color: var(--dark);
        }
        
        .controls {
            margin-bottom: 1.5rem;
            padding: 1.5rem;
            background: var(--white);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
        }
        
        .canvas-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        .canvas-box {
            flex: 1;
            min-width: 400px;
            background: var(--white);
            padding: 1.5rem;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
            transition: var(--transition);
        }
        
        .canvas-box:hover {
            box-shadow: var(--shadow-lg);
            transform: translateY(-3px);
        }
        
        canvas {
            border: 2px solid #e9ecef;
            border-radius: var(--radius-sm);
            cursor: pointer;
            margin-bottom: 0.75rem;
            display: block;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 1.2rem;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: linear-gradient(145deg, #f0f2f5, #ffffff);
            border-radius: var(--radius-md);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            padding: 0.25rem 0.5rem;
            border-radius: var(--radius-sm);
            border: 1px solid #e9ecef;
            background-color: rgba(255, 255, 255, 0.9);
            box-shadow: var(--shadow-sm);
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.1);
        }
        
        .road { background: linear-gradient(135deg, var(--road-color), #ffc107); }
        .building { background: linear-gradient(135deg, var(--building-color), #3f51b5); }
        .park { background: linear-gradient(135deg, var(--park-color), #2dd4bf); }
        .water { background: linear-gradient(135deg, var(--water-color), #0077b6); }
        .other { background: linear-gradient(135deg, var(--other-color), #6c757d); }
        .explored { background-color: var(--explored-color); }
        .path { background-color: var(--path-color); }
        
        .stats {
            margin-top: 1rem;
            font-size: 0.9rem;
            color: var(--gray);
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: var(--radius-sm);
            border-left: 4px solid var(--primary);
        }
        
        .stats p {
            margin-bottom: 0.5rem;
        }
        
        .controls-row {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
            margin-top: 1rem;
        }
        
        button {
            padding: 0.6rem 1.2rem;
            background: linear-gradient(45deg, var(--primary), var(--primary-light));
            color: white;
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-weight: 600;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 5px rgba(67, 97, 238, 0.3);
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        button:hover, button:focus {
            background: linear-gradient(45deg, var(--primary-light), var(--primary));
            box-shadow: 0 4px 10px rgba(67, 97, 238, 0.4);
            transform: translateY(-1px);
        }
        
        button:focus {
            outline: 3px solid rgba(67, 97, 238, 0.5);
        }
        
        button:active {
            transform: translateY(0px);
        }
        
        #edit-mode-btn.active {
            background: linear-gradient(45deg, var(--danger), #b5179e);
            box-shadow: 0 2px 5px rgba(247, 37, 133, 0.3);
        }
        
        #edit-mode-btn.active:hover, #edit-mode-btn.active:focus {
            background: linear-gradient(45deg, #b5179e, var(--danger));
            box-shadow: 0 4px 10px rgba(247, 37, 133, 0.4);
        }
        
        #find-path-btn {
            background: linear-gradient(45deg, var(--success), #0096c7);
            box-shadow: 0 2px 5px rgba(76, 201, 240, 0.3);
        }
        
        #find-path-btn:hover, #find-path-btn:focus {
            background: linear-gradient(45deg, #0096c7, var(--success));
            box-shadow: 0 4px 10px rgba(76, 201, 240, 0.4);
        }
        
        #reset-btn {
            background: linear-gradient(45deg, var(--gray), #495057);
            box-shadow: 0 2px 5px rgba(108, 117, 125, 0.3);
        }
        
        #reset-btn:hover, #reset-btn:focus {
            background: linear-gradient(45deg, #495057, var(--gray));
            box-shadow: 0 4px 10px rgba(108, 117, 125, 0.4);
        }
        
        label {
            font-weight: 500;
            margin-right: 0.5rem;
            color: var(--dark);
        }
        
        select, input[type="range"] {
            padding: 0.5rem;
            border: 1px solid #ced4da;
            border-radius: var(--radius-sm);
            font-family: inherit;
            transition: var(--transition);
        }
        
        select {
            background-color: white;
            min-width: 200px;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.25);
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            width: 150px;
            height: 8px;
            background: linear-gradient(to right, var(--primary-light), var(--primary));
            border-radius: var(--radius-sm);
            border: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: white;
            border: 2px solid var(--primary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .instructions {
            padding: 1.2rem;
            background: linear-gradient(145deg, var(--light), white);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
            line-height: 1.6;
        }
        
        .instructions ul {
            padding-left: 1.5rem;
            margin-top: 0.5rem;
        }
        
        .instructions li {
            margin-bottom: 0.5rem;
        }
        
        /* For better accessibility */
        .visuallyhidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        /* Color mode toggle */
        .color-mode {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: var(--white);
            padding: 0.5rem;
            border-radius: var(--radius-sm);
            box-shadow: var(--shadow-sm);
            display: flex;
            align-items: center;
        }
        
        @media (max-width: 768px) {
            .canvas-box {
                min-width: 100%;
            }
            
            .controls-row {
                flex-direction: column;
                align-items: flex-start;
            }
            
            select, input[type="range"] {
                width: 100%;
                margin-bottom: 0.5rem;
            }
        }
        
        @media (prefers-reduced-motion: reduce) {
            * {
                transition: none !important;
                animation: none !important;
            }
        }

        /* High contrast mode support */
        @media (forced-colors: active) {
            button {
                border: 2px solid ButtonText;
            }
            
            .legend-color {
                border: 1px solid ButtonText;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Smart City Infrastructure Visualization</h1>
        
        <div class="controls">
            <h2>Map & Pathfinding Controls</h2>
            
            <div class="legend">
                <div class="legend-item">
                    <span class="legend-color road" aria-hidden="true"></span>
                    <span>Road</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color building" aria-hidden="true"></span>
                    <span>Building</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color park" aria-hidden="true"></span>
                    <span>Park/Ground</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color water" aria-hidden="true"></span>
                    <span>Water</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color other" aria-hidden="true"></span>
                    <span>Other</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color explored" aria-hidden="true"></span>
                    <span>Explored Nodes</span>
                </div>
                <div class="legend-item">
                    <span class="legend-color path" aria-hidden="true"></span>
                    <span>Final Path</span>
                </div>
            </div>
            
            <div class="controls-row">
                <div>
                    <label for="matrix-select">Select Matrix Map:</label>
                    <select id="matrix-select" aria-label="Select a matrix map"></select>
                </div>
                
                <div>
                    <label for="visualization-speed">Animation Speed:</label>
                    <input type="range" id="visualization-speed" min="1" max="100" value="50" 
                           aria-label="Set animation speed">
                </div>
                
                <div>
                    <button id="find-path-btn" aria-label="Find path">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" style="margin-right: 5px;">
                            <path d="M9 18l6-6-6-6"/>
                        </svg>
                        Find Path
                    </button>
                    <button id="reset-btn" aria-label="Reset visualization">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" style="margin-right: 5px;">
                            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                            <path d="M3 3v5h5"/>
                        </svg>
                        Reset
                    </button>
                    <button id="edit-mode-btn" aria-label="Toggle edit mode">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" style="margin-right: 5px;">
                            <path d="M17 3a2.85 2.85 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/>
                        </svg>
                        Edit Mode: OFF
                    </button>
                </div>
            </div>
        </div>
        
        <div class="canvas-container">
            <div class="canvas-box">
                <h2>Dijkstra Algorithm</h2>
                <canvas id="dijkstra-canvas" width="500" height="500" aria-label="Dijkstra algorithm visualization"></canvas>
                <div id="dijkstra-stats" class="stats">
                    <p>Click two points on the map to set start and end points.</p>
                </div>
            </div>
            
            <div class="canvas-box">
                <h2>A* Algorithm</h2>
                <canvas id="astar-canvas" width="500" height="500" aria-label="A* algorithm visualization"></canvas>
                <div id="astar-stats" class="stats">
                    <p>Click two points on the map to set start and end points.</p>
                </div>
            </div>
        </div>
        
        <div class="instructions">
            <h3>Instructions:</h3>
            <ul>
                <li>Click "Edit Mode: ON" to modify the grid</li>
                <li>When editing, click or drag to cycle through cell types</li>
                <li>Set start and end points by clicking on the grid when not in edit mode</li>
                <li>Click "Find Path" to visualize both algorithms</li>
            </ul>
        </div>
    </div>

    <script>
        // Global variables
        let grid = [];
        let gridRows = 0;
        let gridCols = 0;
        let currentMatrixId = null;
        let cellSize = 20; // Default cell size
        let startPoint = null;
        let endPoint = null;
        let isEditMode = false;
        let currentEditType = "road"; // Default edit type
        const editCycle = ["road", "building", "park", "water", "other"];
        
        // Variables for drag editing
        let isDragging = false;
        let lastEditedCell = null;
        
        // Canvas contexts
        const dijkstraCanvas = document.getElementById('dijkstra-canvas');
        const dijkstraCtx = dijkstraCanvas.getContext('2d');
        const astarCanvas = document.getElementById('astar-canvas');
        const astarCtx = astarCanvas.getContext('2d');
        
        // Algorithm visualization data
        let dijkstraVisualization = {
            explored: new Set(),
            path: [],
            steps: [],
            currentStep: 0,
            nodesExplored: 0,
            pathLength: 0,
            executionTime: 0
        };
        
        let astarVisualization = {
            explored: new Set(),
            path: [],
            steps: [],
            currentStep: 0,
            nodesExplored: 0,
            pathLength: 0,
            executionTime: 0
        };
        
        // Fetch available matrix maps and populate the dropdown
        fetch('/api/map/matrix/')
            .then(response => response.json())
            .then(matrices => {
                const select = document.getElementById('matrix-select');
                matrices.forEach(matrix => {
                    const option = document.createElement('option');
                    option.value = matrix.id;
                    option.textContent = `${matrix.name} (${matrix.X}x${matrix.Y})`;
                    select.appendChild(option);
                });
                
                // Load the first matrix by default
                if (matrices.length > 0) {
                    currentMatrixId = matrices[0].id;
                    loadMatrix(currentMatrixId);
                }
            });
        
        // Event listeners
        document.getElementById('matrix-select').addEventListener('change', function() {
            currentMatrixId = this.value;
            resetVisualization();
            loadMatrix(currentMatrixId);
        });
        
        document.getElementById('find-path-btn').addEventListener('click', function() {
            if (startPoint && endPoint) {
                findAndVisualizeShortestPaths();
            } else {
                alert('Please select start and end points first.');
            }
        });
        
        document.getElementById('reset-btn').addEventListener('click', resetVisualization);
        
        document.getElementById('edit-mode-btn').addEventListener('click', function() {
            isEditMode = !isEditMode;
            this.textContent = `Edit Mode: ${isEditMode ? 'ON' : 'OFF'}`;
            if (isEditMode) {
                this.classList.add('active');
            } else {
                this.classList.remove('active');
            }
            resetVisualization();
        });
        
        // Handle mouse events for draggable editing
        function setupMouseEvents(canvas, ctx) {
            // Mouse down - start dragging
            canvas.addEventListener('mousedown', function(event) {
                if (isEditMode) {
                    isDragging = true;
                    const cell = getCellFromEvent(event, canvas);
                    if (cell) {
                        lastEditedCell = cell;
                        changeCellType(cell.x, cell.y);
                    }
                } else {
                    // Regular click handling for non-edit mode
                    handleCanvasClick(event, canvas, ctx);
                }
            });
            
            // Mouse move - continue dragging
            canvas.addEventListener('mousemove', function(event) {
                if (isEditMode && isDragging) {
                    const cell = getCellFromEvent(event, canvas);
                    if (cell && (lastEditedCell === null || cell.x !== lastEditedCell.x || cell.y !== lastEditedCell.y)) {
                        lastEditedCell = cell;
                        changeCellType(cell.x, cell.y);
                    }
                }
            });
            
            // Mouse up - stop dragging
            canvas.addEventListener('mouseup', function() {
                isDragging = false;
                lastEditedCell = null;
            });
            
            // Mouse leave - stop dragging
            canvas.addEventListener('mouseleave', function() {
                isDragging = false;
                lastEditedCell = null;
            });
        }
        
        // Set up mouse events for both canvases
        setupMouseEvents(dijkstraCanvas, dijkstraCtx);
        setupMouseEvents(astarCanvas, astarCtx);
        
        function getCellFromEvent(event, canvas) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((event.clientX - rect.left) / cellSize);
            const y = Math.floor((event.clientY - rect.top) / cellSize);
            
            if (x < 0 || x >= gridCols || y < 0 || y >= gridRows) return null;
            return { x, y };
        }
        
        // Fix how points are accessed to match the grid structure
        function changeCellType(x, y) {
            // Get current cell type - Note that grid[y][x] is correct here
            let currentIndex = editCycle.indexOf(grid[y][x].represents);
            currentIndex = (currentIndex + 1) % editCycle.length;
            grid[y][x].represents = editCycle[currentIndex];
            
            // Update the cell in both canvases
            drawCell(dijkstraCtx, x, y, grid[y][x].represents);
            drawCell(astarCtx, x, y, grid[y][x].represents);
            
            // Save the change to the server
            updateCellType(currentMatrixId, x, y, grid[y][x].represents);
        }
        
        // Handle regular click events (non-dragging)
        function handleCanvasClick(event, canvas, ctx) {
            const cell = getCellFromEvent(event);
            if (!cell) return;
            
            if (isEditMode) {
                changeCellType(cell.x, cell.y);
            } else {
                // Path finding mode: Set start/end points
                if (!startPoint) {
                    startPoint = { x: cell.x, y: cell.y };
                    drawStartPoint(dijkstraCtx, cell.x, cell.y);
                    drawStartPoint(astarCtx, cell.x, cell.y);
                } else if (!endPoint) {
                    endPoint = { x: cell.x, y: cell.y };
                    drawEndPoint(dijkstraCtx, cell.x, cell.y);
                    drawEndPoint(astarCtx, cell.x, cell.y);
                } else {
                    // Reset and set new start point
                    resetVisualization();
                    startPoint = { x: cell.x, y: cell.y };
                    drawStartPoint(dijkstraCtx, cell.x, cell.y);
                    drawStartPoint(astarCtx, cell.x, cell.y);
                }
            }
        }
        
        // Update cell type on the server with improved error handling
        function updateCellType(matrixId, x, y, represents) {
            console.log(`Updating cell (${x},${y}) to type: ${represents}`);
            
            fetch(`/api/map/points/${matrixId}/${x}/${y}/`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({ represents }),
                credentials: 'same-origin'
            })
            .then(response => {
                if (!response.ok) {
                    console.error(`Server returned error ${response.status} for update of cell (${x},${y})`);
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                console.log(`Cell (${x},${y}) updated successfully to ${data.represents}`);
                
                // Update the local grid to match the server response
                grid[y][x].represents = data.represents;
            })
            .catch(error => {
                console.error('Error updating cell:', error);
                
                // Refresh the grid to ensure UI matches the server state
                if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
                    console.error('Network error, consider refreshing the page');
                }
            });
        }
        
        // Load matrix data from the server with debugging
        function loadMatrix(matrixId) {
            console.log(`Loading matrix ${matrixId}...`);
            
            fetch(`/api/map/canvas/?matrix_id=${matrixId}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Failed to load matrix: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    grid = data.grid;
                    gridRows = grid.length;
                    gridCols = grid[0].length;
                    
                    console.log(`Loaded grid: ${gridRows}x${gridCols}`);
                    
                    // Count road cells for debugging and verify coordinate order
                    let roadCount = 0;
                    for (let y = 0; y < gridRows; y++) {
                        for (let x = 0; x < gridCols; x++) {
                            if (grid[y][x].represents === 'road') {
                                roadCount++;
                                console.log(`Road at: (${x}, ${y})`);
                            }
                        }
                    }
                    console.log(`Found ${roadCount} road cells in the grid`);
                    
                    // Adjust canvas sizes based on grid dimensions
                    const maxWidth = 500;
                    const maxHeight = 500;
                    cellSize = Math.min(maxWidth / gridCols, maxHeight / gridRows);
                    
                    dijkstraCanvas.width = cellSize * gridCols;
                    dijkstraCanvas.height = cellSize * gridRows;
                    astarCanvas.width = cellSize * gridCols;
                    astarCanvas.height = cellSize * gridRows;
                    
                    drawGrid(dijkstraCtx);
                    drawGrid(astarCtx);
                })
                .catch(error => {
                    console.error('Error loading matrix:', error);
                });
        }
        
        // Draw the complete grid
        function drawGrid(ctx) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            for (let y = 0; y < gridRows; y++) {
                for (let x = 0; x < gridCols; x++) {
                    drawCell(ctx, x, y, grid[y][x].represents);
                }
            }
        }
        
        // Draw a single cell
        function drawCell(ctx, x, y, type) {
            const colors = {
                'road': '#ffd166',
                'building': '#4361ee',
                'park': '#06d6a0',
                'water': '#118ab2',
                'other': '#adb5bd'
            };
            
            // Fill with solid color first (for accessibility)
            ctx.fillStyle = colors[type] || colors.other;
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
            
            // Add subtle gradient effect
            if (cellSize > 5) { // Only add gradient if cells are big enough
                const gradient = ctx.createLinearGradient(
                    x * cellSize, 
                    y * cellSize, 
                    x * cellSize + cellSize, 
                    y * cellSize + cellSize
                );
                
                let startColor, endColor;
                
                switch(type) {
                    case 'road':
                        startColor = '#ffd166';
                        endColor = '#ffc107';
                        break;
                    case 'building':
                        startColor = '#4361ee';
                        endColor = '#3f51b5';
                        break;
                    case 'park':
                        startColor = '#06d6a0';
                        endColor = '#2dd4bf';
                        break;
                    case 'water':
                        startColor = '#118ab2';
                        endColor = '#0077b6';
                        break;
                    default:
                        startColor = '#adb5bd';
                        endColor = '#6c757d';
                }
                
                gradient.addColorStop(0, startColor);
                gradient.addColorStop(1, endColor);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
            }
            
            // Add border
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
        
        // Draw start point marker
        function drawStartPoint(ctx, x, y) {
            drawCell(ctx, x, y, grid[y][x].represents); // Draw base cell
            ctx.fillStyle = 'rgba(0, 255, 0, 0.5)'; // Semi-transparent green
            ctx.beginPath();
            ctx.arc(
                (x + 0.5) * cellSize,
                (y + 0.5) * cellSize,
                cellSize * 0.4,
                0, Math.PI * 2
            );
            ctx.fill();
            ctx.stroke();
        }
        
        // Draw end point marker
        function drawEndPoint(ctx, x, y) {
            drawCell(ctx, x, y, grid[y][x].represents); // Draw base cell
            ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; // Semi-transparent red
            ctx.beginPath();
            ctx.arc(
                (x + 0.5) * cellSize,
                (y + 0.5) * cellSize,
                cellSize * 0.4,
                0, Math.PI * 2
            );
            ctx.fill();
            ctx.stroke();
        }
        
        // Find and visualize shortest paths using both algorithms
        function findAndVisualizeShortestPaths() {
            if (!startPoint || !endPoint) return;
            
            resetAlgorithmVisualizations();
            
            console.log(`Finding path from (${startPoint.x},${startPoint.y}) to (${endPoint.x},${endPoint.y})`);
            console.log(`Start point type: ${grid[startPoint.y][startPoint.x].represents}`);
            console.log(`End point type: ${grid[endPoint.y][endPoint.x].represents}`);
            
            // If start or end are not roads, notify user
            if (grid[startPoint.y][startPoint.x].represents !== 'road' || 
                grid[endPoint.y][endPoint.x].represents !== 'road') {
                alert('Both start and end points must be road cells. Please select road cells for pathfinding.');
                document.getElementById('dijkstra-stats').innerHTML = 
                    '<p>Error: Both start and end must be road cells</p>';
                document.getElementById('astar-stats').innerHTML = 
                    '<p>Error: Both start and end must be road cells</p>';
                return;
            }
            
            // Request Dijkstra path
            console.log("Requesting Dijkstra path...");
            requestPathfinding('dijkstra', dijkstraVisualization, dijkstraCtx, 'dijkstra-stats');
            
            // Request A* path separately to avoid interference
            setTimeout(() => {
                console.log("Requesting A* path...");
                requestPathfinding('astar', astarVisualization, astarCtx, 'astar-stats');
            }, 500);
        }
        
        function requestPathfinding(algorithm, visualization, ctx, statsId) {
            fetch('/api/map/pathfinding/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    map_id: currentMatrixId,
                    start_x: startPoint.x,
                    start_y: startPoint.y,
                    end_x: endPoint.x,
                    end_y: endPoint.y,
                    algorithm: algorithm
                }),
                credentials: 'same-origin'
            })
            .then(response => {
                console.log(`${algorithm} response status:`, response.status);
                return response.json();
            })
            .then(data => {
                console.log(`${algorithm} response data:`, data);
                
                if (data.error) {
                    console.error(`${algorithm} error:`, data.error);
                    document.getElementById(statsId).innerHTML = 
                        `<p>Error: ${data.error}</p>`;
                    return;
                }
                
                if (!data.path || data.path.length === 0) {
                    console.error(`${algorithm}: Empty path returned`);
                    document.getElementById(statsId).innerHTML = 
                        `<p>Error: No valid path was returned</p>`;
                    return;
                }
                
                visualization.path = data.path;
                visualization.explored = new Set(data.explored.map(p => `${p[0]},${p[1]}`));
                visualization.nodesExplored = data.explored.length;
                visualization.pathLength = data.path.length;
                visualization.executionTime = data.execution_time;
                
                console.log(`${algorithm} path found with ${visualization.nodesExplored} nodes explored`);
                
                // Animate algorithm
                animateAlgorithm(algorithm);
                
                // Update stats display
                document.getElementById(statsId).innerHTML = 
                    `<p>Nodes Explored: ${visualization.nodesExplored}</p>
                     <p>Path Length: ${visualization.pathLength}</p>
                     <p>Execution Time: ${visualization.executionTime.toFixed(2)} ms</p>`;
            })
            .catch(error => {
                console.error(`${algorithm} fetch error:`, error);
                document.getElementById(statsId).innerHTML = 
                    `<p>Error: ${error.message}</p>`;
            });
        }
        
        // Animate algorithm visualization
        function animateAlgorithm(algorithm) {
            const visualization = algorithm === 'dijkstra' ? dijkstraVisualization : astarVisualization;
            const ctx = algorithm === 'dijkstra' ? dijkstraCtx : astarCtx;
            
            // Reset canvas first
            drawGrid(ctx);
            if (startPoint) drawStartPoint(ctx, startPoint.x, startPoint.y);
            if (endPoint) drawEndPoint(ctx, endPoint.x, endPoint.y);
            
            // Animation speed (from slider)
            const speed = document.getElementById('visualization-speed').value;
            const exploredDelay = 2000 / Math.max(1, visualization.nodesExplored) * (100 - speed) / 100;
            
            // Animate explored nodes first
            let exploredPoints = Array.from(visualization.explored).map(p => p.split(',').map(Number));
            let exploredIndex = 0;
            
            function animateExplored() {
                if (exploredIndex < exploredPoints.length) {
                    const [x, y] = exploredPoints[exploredIndex];
                    
                    // Skip start and end points
                    if (!(x === startPoint.x && y === startPoint.y) && 
                        !(x === endPoint.x && y === endPoint.y)) {
                        drawExploredNode(ctx, x, y);
                    }
                    
                    exploredIndex++;
                    setTimeout(animateExplored, exploredDelay);
                } else {
                    // After explored animation completes, animate the path
                    animatePath();
                }
            }
            
            function animatePath() {
                const pathDelay = 100 * (100 - speed) / 100;
                let pathIndex = 0;
                
                function drawPathStep() {
                    if (pathIndex < visualization.path.length) {
                        const [x, y] = visualization.path[pathIndex];
                        
                        // Skip start and end points
                        if (!(x === startPoint.x && y === startPoint.y) && 
                            !(x === endPoint.x && y === endPoint.y)) {
                            drawPathNode(ctx, x, y);
                        }
                        
                        pathIndex++;
                        setTimeout(drawPathStep, pathDelay);
                    }
                }
                
                drawPathStep();
            }
            
            animateExplored();
        }
        
        // Draw an explored node
        function drawExploredNode(ctx, x, y) {
            drawCell(ctx, x, y, grid[y][x].represents); // Draw base cell
            ctx.fillStyle = 'rgba(247, 37, 133, 0.3)'; // Semi-transparent pink
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
        
        // Draw a path node
        function drawPathNode(ctx, x, y) {
            drawCell(ctx, x, y, grid[y][x].represents); // Draw base cell
            ctx.fillStyle = 'rgba(247, 37, 133, 0.8)'; // More opaque pink
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
        
        // Reset algorithm visualizations
        function resetAlgorithmVisualizations() {
            dijkstraVisualization = {
                explored: new Set(),
                path: [],
                steps: [],
                currentStep: 0,
                nodesExplored: 0,
                pathLength: 0,
                executionTime: 0
            };
            
            astarVisualization = {
                explored: new Set(),
                path: [],
                steps: [],
                currentStep: 0,
                nodesExplored: 0,
                pathLength: 0,
                executionTime: 0
            };
        }
        
        // Reset the entire visualization
        function resetVisualization() {
            startPoint = null;
            endPoint = null;
            resetAlgorithmVisualizations();
            
            drawGrid(dijkstraCtx);
            drawGrid(astarCtx);
            
            document.getElementById('dijkstra-stats').innerHTML = 
                '<p>Click two points on the map to set start and end points.</p>';
            document.getElementById('astar-stats').innerHTML = 
                '<p>Click two points on the map to set start and end points.</p>';
        }
        
        // Get CSRF token from cookies
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
    </script>
</body>
</html>
